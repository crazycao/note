# 前端面试题 

## 从浏览器地址栏输入url到显示页面的步骤

- 浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；
- 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；
- 浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；
- 载入解析到的资源文件，渲染页面，完成。

> URL->DNS域名解析->真实IP->发起请求->服务端数据处理->返回数据->浏览器接收文件->加载文件资源->语法解析->建立内部数据结构DOM->载入资源文件（图片等）->渲染页面->完成

## 如何进行网站性能优化

- content方面

	- 减少HTTP请求：合并文件、CSS精灵、inline Image
	- 减少DNS查询：DNS缓存、将资源分布到恰当数量的主机名
	- 减少DOM元素数量
- Server方面

	- 使用CDN
	- 配置ETag
	- 对组件使用Gzip压缩
- Cookie方面

	- 减小cookie大小
- css方面

	- 将样式表放到页面顶部
	- 不使用CSS表达式
	- 使用`<link>`不使用`@import`
- Javascript方面

	- 将脚本放到页面底部
	- 将javascript和css从外部引入
	- 压缩javascript和css
	- 删除不需要的脚本
	- 减少DOM访问
- 图片方面

	- 优化图片：根据实际颜色需要选择色深、压缩
	- 优化css精灵
	- 不要在HTML中拉伸图片

## 请描述一下 cookies，sessionStorage 和 localStorage 的区别？

- 与服务端交互
	- cookie 是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）
	- cookie 数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递
	- sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存

- 存储大小：

	- cookie数据大小不能超过4k
	- sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大
- 有效时间：

	- localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据
	- sessionStorage 数据在当前浏览器窗口关闭后自动删除
	- cookie 在设置的过期时间之前一直有效，即使窗口或浏览器关闭

## Canvas和SVG有什么区别？

- svg绘制出来的每一个图形的元素都是独立的DOM节点，能够方便的绑定事件或用来修改。canvas输出的是一整幅画布。
- svg输出的图形是矢量图形，后期可以修改参数来自由放大缩小，不会是真和锯齿。而canvas输出标量画布，就像一张图片一样，放大会失真或者锯齿。

## 前端安全方面有没有了解？XSS和CSRF如何攻防？

> XSS(Cross Site Scripting)是跨站脚本攻击，为了区分CSS，所以缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。
> 
> 例如，在网页的一些公共区域（例如，建议提交表单或消息公共板的输入表单）输入一些可以在客户端执行的脚本，如`"/> <script>alert(document.cookie);</script><!--`。在文本框中输入以上代码，然后点击提交，就会把用户的cookie弹出来。

修复方法：

1. 将重要的cookies标记为HTTP ONLY。
2. 只允许用户输入我们期望的数据。如年龄框只能输入数字。
3. 对数据进行HTTP Encode处理。
4. 过滤或者移除特殊的HTML标签。
5. 过滤JS事件的标签。

> CSRF（Cross-site request forgery）是跨站请求伪造。攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。
> 
> 典型的CSRF攻击流程：
> 1. 受害者登录 `a.com`，并保留了登录凭证（Cookie）。
> 2. 攻击者引诱受害者访问了 `b.com`。
> 3. `b.com` 向 `a.com` 发送了一个请求：`a.com/act=xx`。浏览器会默认携带 `a.com` 的Cookie。
> 4. `a.com` 接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。
> 5. `a.com` 以受害者的名义执行了 `act=xx`。
> 6. 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让 `a.com` 执行了自己定义的操作。

修复方法：

1. Token 验证。不是验证浏览器自动携带的 cookie，而是需要主动携带 token。一般 token 放在请求头里，也可以在表单提交的请求体里携带 token。
2. Refer 验证。Referer 指的是页面请求来源。只接受本站的请求，服务器才做响应；如果不是，就拦截。