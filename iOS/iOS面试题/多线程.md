# 多线程

## 多线程是什么？
- 同步完成多项任务，提高了资源的使用效率。
- 多线程的实现原理：同一时间内单核的CPU只能执行一个线程，多线程是CPU快速的在多个线程之间进行切换（调度），造成了多个线程同时执行的假象。
- 如果是多核CPU就真的可以同时处理多个线程了。

## 并行和并发的区别？
- 如果某个系统支持两个或者多个动作**同时存在**，那么这个系统就是一个**并发系统**。
	- 吃饭时，电话来了，能够接起电话，就做到了并发。
	- 在并发程序中可以同时拥有两个或者多个线程。
- 如果某个系统支持两个或者多个动作**同时执行**，那么这个系统就是一个**并行系统**。
	- 吃饭时，电话来了，能够一边吃饭一边接电话，就做到了并行。
	- 如果程序能够并行执行，那么就一定是运行在多核处理器上。
- 可见，**“并行”概念是“并发”概念的一个子集。**

## iOS中实现多线程的几种方案，各自有什么特点？
- iOS 中的多线程主要有三种：NSThread、NSOperationQueue、GCD。
- **NSThread**：控制线程执行的对象。它不如NSOperation抽象，通过它我们可以方便的得到一个线程，并控制它。每个NSThread对象对应一个线程。
	- 优点：NSThread 比其他两个轻量级，使用简单。（如 `performSelector...` 系列。）
	- 缺点：需要自己管理线程的生命周期、线程同步、加锁、睡眠以及唤醒等。
	- 缺点：线程同步对数据的加锁会有一定的系统开销。
- **NSOperation**：面向对象的线程技术。它用GCD构建封装的，是GCD的高级抽象。
	- 优点：不需要关心线程管理，数据同步的事情，可以把精力放在自己需要执行的操作上。
	- 缺点：只能实现或者使用它定义好的两个子类：NSInvocationOperation 和 NSBlockOperation。
- **GCD**：Grand Central Dispatch (GCD)是Apple开发的一个多核编程的解决方法。是面向底层的C语言的一套API。
	- 优点：充分利用了设备的多核，自动管理线程生命周期。比NSOperation效率更高。任务都是block，写起来也更方便。
	- 缺点：GCD只支持 **FIFO** 的队列，而NSOperationQueue可以通过设置最大并发数，设置优先级，添加依赖关系等调整执行顺序。

## 怎样的情况会造成死锁？

- 在主线程中运用主队列同步，也就是把同步任务放到了主线程的队列中。

	```
	- (void)viewDidLoad {
    	[super viewDidLoad];

    	dispatch_sync(dispatch_get_main_queue(), ^{
        	NSLog(@"deadlock");
    	});
   }
	``` 
	- 同步任务需要立即执行，`viewDidLoad` 需要等待同步任务完成后才会继续执行。
	- 同步任务被放到了主队列中，该任务需要等待 `viewDidLoad` 执行完成后才能开始执行。
- 在一个串行队列维护的线程内，让该串行队列执行同步任务。原理与上方相同。

	```
	dispatch_queue_t serialQueue = dispatch_queue_create("test", DISPATCH_QUEUE_SERIAL);
	dispatch_async(serialQueue, ^{
        dispatch_sync(serialQueue, ^{
            NSLog(@"deadlock");
        });
    });
    ```
- 解决方案：
	- 将同步任务改成异步任务 `dispatch_async`。
	- 使用两个不同的队列来完成任务。另一个队列是串行或并行都没有影响。

