# Swift4从零到精通iOS开发

# 第1章 学习环境的搭建
# 第2章 量值与基本数据类型
## 2.1 变量与常量
## 2.2 关于注释
## 2.3 基本数据类型
## 2.4 两种特殊的基本数据类型
## 2.5 为类型取别名
# 第3章 字符、字符串与集合类型
## 3.1 字符串类型
## 3.2 字符类型
## 3.3 字符串类型中的常用方法
## 3.4 集合类型
### 3.4.1 Array数组类型
### 3.4.2 Set集合类型

- 不关注其中元素的顺序，但是其中的元素不可以重复。
- Set集合可以进行数学运算，如交集、并集、补集等。

### 3.4.3 Dictionary字典类型
# 第4章 基本运算符与程序流程控制
## 4.1 初识运算符
### 4.1.1 赋值运算符（=）
### 4.1.2 基本算数运算符（+、-、*、/、%）

- Swift 2.2 之后删除了自增运算符（++）和自减运算符（--）。

### 4.1.3 基本逻辑运算符（&&、||、!）
### 4.1.4 比较运算符（==、<、>、!=、<=、>=）
### 4.1.5 条件运算符（?:）
## 4.2 两种特殊的运算符
### 4.2.1 空合并运算符（??）

- `q ?? 0` 等价于 `(q!=nil)?(q!):0`，非空则拆包，否则取第二个值。

### 4.2.2 区间运算符（...、..<、>..、~=）

- `0...10` 表示 >=0 且 <=10 的闭区间
- `0..<10` 表示 >=0 且 <10 的半开区间
- `range1~=8` 表示 8 是否包含于区间 range1 中

## 4.3 循环结构
### 4.3.1 for-in循环结构

- Swift 2.2 之后删除了经典的 `for()` 循环结构。`for-in` 结构已经完全覆盖其功能。
- `for-in` 结构中需要两个参数：
	- 第2个参数既可以是一个集合类型的实例（Array/Dictionary/Set），也可以是一个范围区间（如 `1...5`）；
	- 第1个参数为捕获参数，每次从第2个参数中遍历出的元素便会赋值给它，可供开发者在循环结构中直接使用。
- 如果在进行循环遍历的时候，开发者并不需要使用捕获到的值，可以使用匿名参数（`_`符号）来接收。

### 4.3.2 while与repeat-while条件循环结构

- 在 Swift 中的 `while` 结构与 C/OC 中的 `while` 完全相同。
- 在 Swift 中的 `repeat-while` 结构与 C/OC 中的 `do-while` 完全相同，只是改了个名字。

## 4.4 条件选择与多分支选择结构
### 4.4.1 if与if-else条件选择结构

- `if` 关键字后面的条件必须为严格意义上的逻辑值或者结果为逻辑值的表达式，这一点与 C/OC不同
- `if-else` 结构中的每个分支是互斥的，只能有一个分支的代码被执行，条件的判断顺序会从上到下进行，直到找到一个条件为真的分支或者最后一个 `else` 语句。

### 4.4.2 switch-case多分支选择结构

- Swift 中的 `switch` 语句支持任意数据类型的匹配
- 一个 `case` 子句匹配成功执行后，不用写break，会自动跳出switch结构，这与 C/OC 有很大不同
- `case` 子句中支持编写多个匹配条件，中间用逗号隔开，只要有一个条件匹配成功，就会执行此 `case` 下的代码。
- `case` 子句的匹配条件可以是一个区间范围，当要匹配的参数在这个区间范围内时，就会执行此 `case` 下的代码。
- `case` 子句可以捕获 `switch` 元组的参数，并在相应的 `case` 代码块中直接使用捕获到的参数
	- 要捕获的元素并不能起到匹配的作用
	- 下面的例子中，若前两个 `case` 未命中，第3个 `case` 始终会匹配成功 

```
var tuple = (1, 2)
switch tuple:
	case (let a, 1):
		print(a)
	case (let b, 2):
		print(b)
	case (let a, b):
		print(a, b)
	default:
		print(tuple)
```

- 可以在 `case` 子句中追加 `where` 条件，如 `case (let a, 1) where a == 0`，`case (let a, b) where a == b`。

## 4.5 流程跳转语句
- continue：跳过本次循环，直接进入下一个循环周期
- break：终端循环
- fallthrough：需要switch-case结构不自动跳出，而执行下一个条件判断。写在之前break的位置。
- return：返回结果值
- throw：异常抛出。throw语句抛出的异常如果不进行捕获处理，也会使程序中断。
- guard：确保某个条件成立后才允许其后面的代码执行。

# 第5章 函数与闭包技术
## 5.1 函数的基本应用
- 完整的函数声明：

	```
	func 函数名(外部参数名1 内部参数名1:参数类型, 外部参数名2 内部参数名2:参数类型, ...)->返回值类型 {
	 // 实现部分 
	}
	```
- 函数的调用：

	```
	返回值 = 函数名(外部参数名1:参数值1, 外部参数名2:参数值2, ...)
	```

### 5.1.1 函数的创建与调用
### 5.1.2 关于函数的参数名
- 参数的外部名称会在调用函数时标识参数，既简化了函数名（OC），也能识别每个参数的意义（Java）。
- 可以省略函数参数的外部名称，默认函数的外部名称与内部名称相同。

### 5.1.3 函数中参数的默认值、不定数量参数与inout参数
- 默认值：在函数声明中，`内部参数名:参数类型`后面加上`= 默认值`。
- 不定数量参数：在函数声明中，`内部参数名:参数类型`后面加上`...`。
- inout类型参数：可以在函数内部修改传递参数的变量的值，`内部函数名:inout 参数类型`；调用函数传参时需要使用`&`符号取地址。

## 5.2 函数的类型与函数嵌套
- 函数变量的类型由参数和返回值决定，参数和返回值相同的函数类型就相同。
- 一个函数的类型形如：`(参数类型1, 参数类型2, ...)->返回值类型`。
- 声明一个函数变量：`var addFunc:(Int, Int)->Int`。

## 5.3 理解闭包结构
### 5.3.1 闭包的语法结构
- 标准闭包结构：`{(参数列表)->返回值 in 闭包体}`
- 闭包的返回值可以省略，会根据闭包体 `return` 返回的数据类型推测。

### 5.3.2 通过实现一个排序函数来深入理解闭包
## 5.4 将闭包作为参数传递时的写法优化
## 5.5 后置闭包、逃逸闭包与自动闭包
### 5.5.1 后置闭包
- 当函数中的最后一个参数为闭包函数时，在调用函数时，开发者可以将闭包结构脱离出函数的参数列表，追加在函数的尾部，增强代码的可读性。
- `函数名(参数1: 参数值, 参数2: 闭包体)`使用后置闭包的写法为：`函数名(参数1: 参数值)函数体`。

### 5.5.2 逃逸闭包
- 逃逸闭包，是指函数内的闭包在函数执行结束后在函数外依然可以进行使用；非逃逸闭包是指当函数的生命周期结束后，闭包也将被销毁。
- 参数中的闭包默认都是非逃逸的。逃逸类型的闭包常用于异步操作中。
- 逃逸闭包需要使用 @escaping 来声明。`func 函数名(参数名: @escaping 闭包声明)`。

### 5.5.3 自动闭包
- 在函数参数中，自动生成的简单闭包，通常称为自动闭包。
- 自动闭包不能够有参数，并且在调用函数传参时，此闭包的实现智能由一句表达式组成，闭包的返回值即为此表达式的值。
- 自动闭包参数由 `@autoclosure` 来声明.

# 第6章 高级运算符与枚举
## 6.1 位运算与溢出运算符
### 6.1.1 位运算符的应用
- `~`：按位取反运算符
- `&`：按位与运算符
- `|`：按位或运算符
- `^`：按位异或运算符
- `<<`：按位左移运算符
- `>>`：按位右移运算符

### 6.1.2 溢出运算符
溢出运算支持超出当前数据类型，取值仍截取当前数据类型。比如，
```
var b:UInt8 = 255
b = b &+ 1 // b 值变为 0

- `&+`：支持溢出的加操作
- `&-`：支持溢出的减操作
- `&*`：支持溢出的乘操作

## 6.2 运算符的重载与自定义
### 6.2.1 重载运算符
- 运算符的重载是指在系统已经存在的运算符上扩展新的功能。
- 重载运算符的语法格式与函数十分相似。

### 6.2.2 自定义运算符
- 开发者也可以通过自定义系统不存在的运算符来实现特殊的需求。
- 自定义运算符分为两个步骤，首先开发者需要将要定义的运算符进行声明，然后通过实现该运算符的函数。

## 6.3 运算符的优先级与结合性
## 6.4 枚举类型的创建与应用

- 创建枚举

```
enum 枚举类型名称 {
	case 枚举值1
	case 枚举值2
	...
}
```

- 使用枚举

```
// 完成写法
var 枚举变量:枚举类型名称 = 枚举类型名称.枚举值
// 如果一个变量的类型已经确认，那么赋值时可以省略枚举名称
var 枚举变量:枚举类型名称 = .枚举值
```

## 6.5 枚举的原始值与相关值
### 6.5.1 枚举的原始值

- 枚举的原始值特性可以将枚举值与另一种数据类型进行绑定

```
enum 枚举类型名称 {
	case 枚举值1 = 原始值1
	case 枚举值2 = 原始值2
	...
}
```

- 如果枚举的原始值类型为 `Int`，可以只设置第一个枚举值的原始值，其后的枚举值的原始值会依次递增。
- 通过枚举类型的中的 `rawValue` 属性来获取原始值

```
var 变量 = 枚举类型名称.枚举值.rawValue // 此后变量的值就是枚举的原始值
```

- 可以通过原始值来构造枚举变量（如果这个枚举有指定的原始值）

```
var 枚举变量 = 枚举类型名称(rawValue: 原始值)
```

### 6.5.2 枚举的相关值

- 枚举的相关值可以为枚举值关联一些其他数据
- 创建带相关值的枚举类型

```
enum 枚举类型名称 {
	case 枚举值1(参数1:参数类型1, 参数2:参数类型2, ...)
	case 枚举值2(参数列表 ...)
	...
} // 每个枚举值的参数列表就被称为为枚举的相关值
```

- 在创建有相关值的枚举实例时，开发者需要提供参数列表中所需要的参数

```
var 枚举变量 = 枚举类型名称.枚举值(参数1:参数值1, 参数2:参数值2, ...)
```

- 在 `switch-case` 结构语句中，可以通过参数捕获的方式来获取枚举变量的相关值，并且相关值参数可以在开发者的代码中使用

```
switch 枚举变量 {
	case let .枚举值1(参数1, 参数2, ...): {
		print("params1:\(参数1), params2:\(参数2)")
	}
	case let .枚举值2(参数列表...): {
	}
	...
}
```

### 6.5.3 递归枚举

- 枚举的递归是指，一个枚举值的相关值类型可以设置为这个枚举本身的类型
- 使用 indirect 关键字修饰的枚举值表示这个枚举值是可以递归的（即此枚举值中的相关值可以使用其枚举类型本身）

```
enum 枚举类型名称 {
	// 普通枚举值
	case 枚举值1
	// 带相关值的枚举值
	case 枚举值2(参数列表...)
	// 可递归的枚举值
	indirect case 枚举值3(参数1:参数类型1, ...) // 参数类型可以是当前枚举类型
}
```

- 如果一个枚举中所有的枚举值都是可递归的，可以直接将整个枚举类型声明为可递归的

```
// 可递归的枚举类型
indirect enum 枚举类型名称 {
	case 枚举值1(参数列表...) // 参数类型可以是当前枚举类型
	...
}
```

# 第7章 类与结构体

## 7.1 类与结构体的定义
### 7.1.1 结构体
- 结构体是用于描述一种事物的结构。
- 使用 `struct` 关键字来定义结构体
- 结构体中可以声明变量或者常量作为结构体的属性，有可以创建函数作为结构体的方法

```
struct 结构体名称 {
	// 属性（变量或常量）
	var 属性1: 类型1
	let 属性2: 类型2
	// 方法
	func 方法名(参数列表) {
		// 方法操作...
	}
}
```

- 结构体、枚举都是值类型，值类型的数据在进行值传递时总是被复制，修改新的实例并不影响原始的实例。
- 结构体实例的初始化

```
var 结构体变量 = 结构体名称(属性1:值1, 属性2:值2)
```

### 7.1.2 类

- 类是编程世界中万物的抽象，使用类可以模拟万物的对象。
- 使用 `class` 关键字来定义类
- 类中声明属性和方法的代码基本都一样，但是类要求开发者自己提供构造方法

```
class 类名 {
	// 属性（变量或常量）
	var 属性1: 类型1
	let 属性2: 类型2
	// 方法
	func 方法名(参数列表) {
		// 方法操作...
	}
	// 构造方法（如果类的每个属性声明时都设置了初始值，就可以不用构造方法）
	init(属性1:类型1, 属性2:类型2) {
		self.属性1 = 参数1
		self.属性2 = 参数2
	}
}
```

- 类是引用类型，通过引用计数来管理其生命周期。对类实例进行数据传递时只传递指针，并不会产生复制行为，修改新的变量会影响到原始变量。

### 7.1.3 类与结构体的异同

- 相同点
	- 都有属性、方法，并且声明代码完全相同
	- 都通过点语法来完成对属性和方法的访问
- 不同点
	- 结构体不具备继承特性
	- 结构体是值类型，类是引用类型
	- 结构体会根据属性自动生成一个构造方法，而类需要开发者自己实现 `init()` 方法
	- 对结构体进行比较，使用 `==`；对类进行比较，使用 `===`。
		- 在 Swift 中， Array、String、Dictionary、Set 这些数据类型都是采用结构体实现的，这与OC有很大的区别。 


## 7.2 设计以及各交通工具类
- `final` 关键字用于修饰某些终极的属性、方法或类。
	- 被 `final` 修饰的属性和方法不能够被子类覆写。
	- 被 `final` 修饰的类不能被继承。

## 7.3 开发中类与结构体的应用场景
- 适合使用结构体的场景：
	- 要描述的数据类型中只有少量的简单数据类型的属性
	- 要描述的数据类型在数据传递时需要以复制的方式进行
	- 要描述的数据类型中的所有属性在进行传递时需要以复制的方式进行
	- 不需要继承另一个数据类型

# 第8章 属性与方法

## 8.1 存储属性与计算属性
- 存储顺序性的作用是存储类的某个特征，而计算属性的作用是通过运算告知外界类的某个特征。
- 存储属性只能用于类和结构体，计算属性可以用于类、结构体和枚举。

### 8.1.1 存储属性的意义及应用
- 存储属性用于定义类或结构体的某些特性。
	- 存储属性就是用变量或常量存储的某些有意义的值。
- 当类实例被构造完成时，必须保证类中所有的属性都构造或者初始化完成。
	- 由开发者在创建的类中提供一个构造方法
	- 也可以为类中的属性在声明时就提供一个初始值
- 所谓延时存储属性就是指在类实例构造的时候，延时属性并不进行构造或初始化，只有当开发者调用到类实例的这个属性时，此属性才完成构造或者初始化操作。
	- 在 `var` 之前加上 `lazy` 修饰，标识这个属性是延时存储属性

```
lazy var 属性名称:类型
```

### 8.1.2 计算属性的意义及应用
- 计算属性用于描述可以由其他属性通过计算而得到的属性。
- 计算属性可以定义 `get` 与 `set` 方法，实际上是作为一个接口向外界提供某些经过计算后具有相应意义的数据。

```
var 属性名称:类型{
	get {
		// 计算过程...
		return 计算结果
	}
	set {
		// 对其他存储属性计算和赋值
		// 外界所设置的值默认以 newValue 的名字传入
	}
}
``` 

- 可以存在没有 `set` 方法块的计算属性，这种属性可以简写如下

```
var 属性名称:类型 {
	// 计算过程...
	return 计算结果
}
```

- 计算属性的值会受到外界影响而变化，一定是一个变量，所以必须用 `var` 修饰

## 8.2 属性监听器
- 属性监听器用于监听存储属性赋值的过程（计算属性不可以）
- 开发者可以在属性监听器中编写代码，添加额外的逻辑
- 在进行属性的构造或初始化时，都不会调用属性监听器的方法；初始化以后的第2次属性赋值开始，属性监听器才生效。

```
var 属性名称:类型 {
	willSet {
		// 属性将要被赋值时会调用的方法
		// 其中会默认生成一个 newValue 来接收外界传进来的新值
	}
	didSet {
		// 属性已经被赋值后会调用的方法
		// 其中会默认生成一个 oldValue 来保存此属性的原始值
	}
}
```

## 8.3 实例属性与类属性
- 实例属性是与具体实例现相关联的，一般用来描述类实例的一些特性；类属性是与此类型相关联的，用来描述整个类型的某些特性。
- 类属性使用 `static` 或 `class` 关键字来声明，使用 `static` 关键字声明的属性也被称为静态属性。

```
class 类名 {
	static var 属性名称: 类型
	class var 属性名称: 类型
}
```

- 使用类属性时，不需要创建实例对象，直接使用类名来调用

```
类名.属性名
```

- 对于类计算属性，如果允许子类对其计算方法进行覆写，则需要用 `class` 关键字来声明，并且覆写时需要使用 `override` 关键字

```
class 类名 {
	class var 属性名称: 类型 {
		return 计算值
	}
}

class 子类名:父类名 {
	override class var 继承的属性名称: 类型 {
		return 覆写计算值
	}
}

```

## 8.4 实例方法与类方法

### 8.4.1 实例方法的意义与应用
- 方法只是一个术语，其实质就是将函数与特定的类型进行结合。
	- 实例方法在语法上与函数完全一致。
- 类的每个实例中都默认隐藏这一个名为 `self` 的属性，`self` 就是实例本身，开发者可以在实例方法中通过 `self` 来调用类的属性和其他实例方法。
	- 一般情况下，`self` 也可以被省略
- 如果需要在实例方法中对类中值类型的属性进行修改，需要用 `mutating` 关键字修饰实例方法

```
mutating func 方法名(参数列表) {
	...
	self.属性名 = xxxx
	...
}
```

### 8.4.2 类方法

- 类方法是关联与整个类型的，被整个类型所共享。
- 类方法的用法与类属性相同，也是通过 `static` 和 `class` 关键字来声明的。
- `static` 关键字声明的类方法又被称为静态方法，不能被子类覆写；`class` 声明的类方法可以被子类覆写。
- 在类方法中也可以使用 `self` 关键字，但此时 `self` 代表的是当前类，而非实例。

## 8.5 下标方法
- 对于Set、Array等数据结构，可以通过使用下标来获取其中的元素，如 array[2]。
- 下标实际上是一个 `subscript` 方法，参数和返回值分别为下标和通过下标所取的值
	- `subscript` 是 Swift 语言中用于定义下标功能的方法
- `subscript` 方法的实现与计算属性十分类似，有一个必须实现的 `get` 代码块和一个可选的 `set` 代码块

# 第9章 构造方法与析构方法

## 9.1 构造方法的设计与使用

- Swift语言要求结构体和类必须在构造方法结束前完成其中存储属性的构造（延时存储属性除外）

- 在Swift中，构造方法不需要使用 `func` 关键字声明，且必须命名为 `init`

- 开发者在设计类时，往往采用两种方式来处理存储属性
	- 在类和结构体中声明存储属性时，直接为其设置初始默认值

 
	- 在类和结构体的构造方法中对存储属性进行构造或者设置默认值

```
// 在声明时直接设置默认值
var 属性1:类型 = 值
// 普通属性必须在构造方法中对其进行赋值
var 属性2:类型
// 对于 Optional 类型的属性（ `类型?` ），如果在构造方法中不进行赋值，就会被默认赋值为 nil 
var 属性3:类型3? 
// 自定义构造方法
init(){
	// 必须对属性2赋值，对于属性1和属性3则非必须
	属性2 = 值
}
```

- 在对存储属性设置默认值或者在构造方法中对其构造时，并不会触发属性监听器，只有在构造完成后，再次对其赋值时才会触发
- 常量属性（`let`修饰）一旦被赋值，就不能再被修改。（在声明时赋值了，在构造函数中就不能修改。）
- 如果开发者不提供自定义构造方法，编译器也会自动生成一个无参的构造方法，所有属性的值都是默认的初始值
- 如果开发者提供了自定义构造方法，那么系统默认生成的构造方法将失效

## 9.2 指定构造方法与便利构造方法

- 指定构造方法（Designated）不需要任何关键字修复，任何类都要至少有一个指定构造方法。
- 便利构造方法（Convenience）需要使用 `convenience` 关键字来修饰，是开发者额外添加的构造方法；便利构造方法最终也要调用指定构造方法。
- Swift语言中对构造方法有如下原则：
	- 子类的指定构造方法中必须调用父类的指定构造方法。
	- 便利构造方法中必须调用当前类的其他构造方法。
	- 便利构造方法归根结底要调用到某个指定构造方法。 
- 指定构造方法是基础的构造方法，便利构造方法是为了方便开发者调用的构造方法。 

## 9.3 构造方法的继承关系

- 构造方法的继承原则
	- 在继承关系中，如果子类没有覆写或者重写任何指定构造方法，则默认子类会继承父类所有的指定构造方法。
	- 如果子类中提供了父类所有的指定构造方法（无论是继承还是覆写），则子类会默认继承父类的便利构造方法。
- 覆写父类的指定构造方法需要使用 `override` 关键字；便利构造方法却没有覆写概念，由于必须调用本类的其他构造方法，所以一定是子类独立的构造方法。

> 覆写与重载的区别：
> 
> 1. 覆写是子类对父类的方法的重新实现，两者用了同一个方法，但是子类有了自己的功能。 
> 2. 重载是使用已有方法相同的方法名，但是通过设置不同的参数个数或者参数类型来实现新的方法。

## 9.4 构造方法的安全性检查

在类的构造方法中，编译器会进行4项安全性检查：

- 检查1：子类的指定构造方法中，必须完成当前类所有存储属性的构造，才能调用父类的指定构造方法。
	- 保证在构造完从父类继承下来的所有存储属性前，本身定义的所有存储属性也已构造完成。 
- 检查2：子类如果要自定义父类中存储属性的值，必须在调用父类的构造方法之后进行设置。
	- 保证子类在设置从父类继承下来的存储属性时，此属性已构造完成。 
- 检查3：如果便利构造方法中需要重新设置某些存储属性的值，必须在调用指定构造方法之后进行设置。
	- 保证便利构造方法中对存储属性值的设置不会被指定构造方法中的设置覆盖。 
- 检查4：子类在调用父类构造方法之前，不能使用 `self` 来引用属性（基类没关系）。
	- 保证在使用 `self` 关键字调用实例本身时，实例已经构造完成。 

## 9.5 可失败构造方法与必要构造方法

- 一个构造方法可能需要一些特定的参数，当传递的参数不符合要求时，开发者可以让这次构造失败，这时就用到了可失败构造方法。

```
init?(参数列表...) // 在该方法的实现中，开发者可以根据需要返回 nil
```

- 开发者也可以设置某些构造方法为必要构造方法，则它的子类必须实现这个构造方法（继承或覆写都可以）

```
required init(参数列表...) // 使用 required 修饰的是必要构造方法
```

## 9.6 析构方法

- 如果将构造方法理解为类实例的创建过程，则析构方法就是类实例的销毁过程。
- 构造方法使用 `init()` 来标识，析构方法使用 `deinit()` 来标识。


# 第10章 内存管理与异常处理

## 10.1 自动引用计数

- 对于值类型的数据传递，其采用的是完全复制的原理，因此原数据的销毁与内存的释放并不会影响新数据，新数据占用的内存会在它本身的作用域结束时释放。
- 对于引用类型的数据内存，只有当没有任何变量引用它时，它才会被释放。
- 自动引用计数指内存管理中对引用采取自动计数的技术。


## 10.2 循环引用及其解决方法

- 对于两个相互引用的实例，一旦造成循环引用，则系统无法完成对其内存的释放与回收。
- Swift 提供了弱引用关键字 `weak` 来处理循环引用的问题。其使用和原理与 OC 相同。
- Swift 弱引用还有一个特点，其只能修饰 Optional 类型的属性，被弱引用的实例释放后，这个属性会被自动设置为 `nil`。
- Swift 还提供了一个关键字 `unowned`(无主引用)来处理非 Optional 值类型属性的循环引用问题。
	- 无主引用与弱引用的最大区别在于，无主引用总是假定属性是不为 `nil` 的，如果属性所引用的实例被销毁释放了，再次使用这个实例的程序会直接崩溃。

## 10.3 闭包中的循环引用

- 在一个类中，如果其有属性为闭包，则也可能产生类与属性之间的互相引用。
	- 闭包中使用的引用类型的实例都会使引用计数加 1。
	- 如果在闭包属性中使用 `self` 关键字，就会对当前类实例本身进行引用计数加 1，而此闭包又是当前类的一个属性，从而产生循环引用，闭包和这个类都无法销毁，造成内存泄漏。
- Swift 语言专门为闭包结构提供了捕获列表来对闭包内使用到的变量或者实例进行弱引用或无主引用的转换。
	- 捕获列表在结构上需要紧跟在闭包的起始大括号后，使用中括号包围。

```
class 类名 {
	var name:String = "hello"
	var 闭包属性名: ()->Void = { [weak self] () in 
		// [weak self] 即为捕获列表，其中对引用到的 self 进行了弱引用转换，也可以使用 [unowned self]
		print(self?.name)
	}
}
```

- 如果闭包的捕获列表中需要对多个引用类型的量值进行引用转换，使用逗号进行分割即可

## 10.4 异常的抛出与传递

- 在 Swift 语言中，所有的错误和异常都由 Error 协议来指定。

```
// 自定义的异常类型
enum MyError: Error {
	// 定义三种异常的枚举值
	case FirstError
	case SecondError
	case ThreddError
}
// 进行异常抛出
throw MyError.FirstError
```

- 通过 `throw` 抛出的异常如果不进行捕获解决，程序会断在抛出异常的地方，不继续向下执行。
- 默认情况下，函数中产生的异常只能在函数内部解决。
- 开发者也可以使用 `throws` 关键字将函数声明为可抛异常函数，即允许开发者在函数外解决函数内部抛出的异常。

```
func 函数名(参数列表) throws -> Void {
	...
	throw MyError.SecondError
}
```

- 对于执行可抛异常的函数，Swift 语言中要使用到 `try` 关键字。
	- `try` 关键字的作用只是试图执行一个可能抛出异常的函数，却并不能捕获与处理异常
	- 捕获与处理异常需要使用到 `do-catch` 结构。  

## 10.5 异常的捕获与处理

- Swift 语言为开发者提供了3中异常处理的方法
	- 使用 `do-catch` 结构来捕获并处理异常
	- 将异常映射为 Optional 值
	- 终止异常传递
- `do-catch` 结构是最常用的异常处理方法，开发者需要将可能抛出异常的代码放入 `do` 结构块中，如果这部分代码中抛出异常，则会从 `catch` 块中寻找对应的异常类型并执行相应的异常处理代码。

```
// 使用 do-catch 进行异常的捕获与处理
do {
	// 执行一个可抛异常函数
	try MyFunction()
} catch MyError.FirstError {
	// 如果抛出第一种异常则执行这一部分代码块
} catch MyError.SecondError {
	// 如果抛出第二种异常则执行这一部分代码块
} catch MyError.ThirdError {
	// 如果抛出第三种异常则执行这一部分代码块
} catch {
	// 如果前面的异常类型都没有匹配上，则执行这一部分代码块
}
```  

- 使用 `try?` 来调用函数可以将异常映射为 Optional 值
	- 如果函数正常运行，则正常返回；如果函数抛出了异常，则会返回 Optional 值 nil

```
// 使用 try? 将异常映射为 Optional 值
var tmp = try? MyFunction()
if tmp == nil {
	print("执行失败，抛出异常")
}
```
> 注意：返回值如果是 `Void` 则并不等于 `nil`。`Void` 是空类型， `nil` 是 Optional 类型的一种特殊值。

- 当开发者可以保证此函数一定不会抛出异常时，可以使用 `try!` 来强行终止异常的传递
	- 此时若这个函数真的抛出了异常，就会产生运行时错误

```
// 使用 try! 终止异常的传递
try! MyFunction()
```

## 10.6 延时执行结构

- Swift 语言中还提供了一种延时执行结构（`defer`），可以保证延时执行结构中的代码块始终在函数要结束时执行。
- 延时执行结构通常用于代码结束前必须执行某段操作的场景中，如释放函数中所使用的一些资源和关闭文件操作等。
- 使用延时执行结构与“将代码块放到函数最后”的区别在于：即使函数因为抛出异常而被中断，`defer` 代码块也会被执行。

```
func 函数名(参数列表) throws -> Void {
	defer {
		// 函数结束前必须执行的代码块
	}
	// 正常函数操作
	...
	// 可能抛出异常
	throw MyError.ThirdError
}
```

# 第11章 类型转换、泛型、扩展与协议

## 11.1 类型检查与转换

### 11.1.1 Swift 语言中的类型检查

- 使用 `is` 关键字组成的判断语句将返回一个布尔值，可以根据结果判断某个实例是否属于某个具体类型

```
if a is String {
	print("a 是一个字符串")
}
```

- 对于有继承关系的类，子类实例进行父类类型的检查会返回成功，反过来则不行

### 11.1.2 Swift 语言中的类型转换

- 使用 `as` 关键字可以完成类型转换
- 类型转换有着向上兼容与向下转换的原则：
	- 一个父类类型的集合可以接收子类类型的实例
	- 在使用上一条原则的父类集合中的实例时，可以将其转换为子类类型

```
if a is String {
	print(a as String)
}
```

- `as?` 是一种比较安全的转换方式。如果类型转换成功，则值为原实例；如果类型转换失败，则会返回 Optional 值 `nil`
- `as!` 是一种强制转换方式，其默认此次转换一定成功。如果转换失败，则会产生运行时错误，程序崩溃。

## 11.2 Any 与 AnyObject 类型

- 在 OC 中，使用 `id` 类型来描述通用的对象类型；在 Swift 中，可以使用 `AnyObject` 来作为引用类型的通用类型。
	- 注意：`AnyObject` 是通用的引用类型，并不能用来描述值类型。
- 在 Swift 中提供了一种更加通用的类型 `Any`，可以用来描述任意类型，包括值类型和引用类型。  

## 11.3 泛型

### 11.3.1 初始泛型

- 简单理解，泛型通常用来表达一种未定的数据类型。
- 泛型可以作为函数的参数，其语法为：在函数参数列表前使用尖括号，将要定义的泛型类型列出，其作用域为函数的参数列表和整个函数的实现部分。

```
// 定义泛型T
func exchange<T>(p1: inout T, p2: inout T) {
	// 该函数的功能为对两个 inout 且类型相同的参数进行值交换
	// 该函数对参数的具体类型并没有妖气，只是要求两个参数类型相同即可
	let tmp = p1
	p1 = p2
	p2 == tmp
}
```

- 上面例子中的 `T` 只是自定义的一个泛型类型名称，也可以是任何其他名字。
- 如果要在一个函数中定义多个泛型，在尖括号内使用逗号进行分割即可。
- 在声明 Array、Dictionary 等集合类型时，可以同时设置这些集合类型中索要存放的元素的类型。这实际上就是通过泛型来实现的。具体见源码中的实现结构体。

```
// 定义一个栈结构体，ItemType 为定义栈中元素类型的泛型
struct Stack<ItemType> {
	var items:[ItemType] = []
	mutating func push(param:ItemType) {
		self.items.append(param)
	}
	mutating func pop()->ItemType {
		return self.items.removeLast()
	}
}
```

### 11.3.2 对泛型进行约束

- 在 Swift 语言中，可以通过两种方式对泛型进行约束：一种是通过继承基类或者遵守协议来进行约束，另一种是通过 `where` 子句来进行约束。
- 使用继承的方式约束泛型的类型。可以用来限制该泛型必须为某一类型或者继承于该类型而来的子类。

```
// 只有 MyClass 类型的或 MyClass 类型的子类才能够作为 Stack 的元素
struct Stack<ItemType: MyClass> {
	...
}
```

- 使用遵守协议的方式约定泛型。可以用来限制该泛型必须为遵守某一协议的类型。

```
// 只有遵守了 MyProtocol 协议的类型才能够作为 Stack 的元素
struct Stack<ItemType: MyProtocol> {
	...
}
```

- 使用 `where` 子句与泛型进行结合，可以为泛型添加更加严格的类型约束。

```
// 要求 T1 为整型，T2 为浮点型
func exchange<T1, T2> where T1:Integer,T2:Float (p1: inout T1, p2: inout T2) {
	...
}
```

## 11.4 扩展与协议

### 11.4.1 使用扩展对已经存在的数据类型进行补充

- Swift 语言中的扩展与 OC 中的类别相似，不同之处在于类别是有名称的，而扩展是没有名称的。
- Swift 语言中的扩展支持如下功能：
	- 添加计算属性
	- 定义实例方法和类方法
	- 定义新的构造方法
	- 定义下标方法
	- 定义嵌套类型
	- 使一个已有的类型遵守协议
	- 对协议进行扩展添加新的属性或方法约定
- 在语法上，扩展使用 `extension` 关键字来进行定义

```
class MyClass {
	// 方法和属性
}
// 为 MyClass 添加扩展
extension MyClass {
	// 扩展的方法和属性
}
// 通过扩展使 MyClass 遵守协议
extionsion MyClass: MyProtocol {
	// 一旦遵守协议，就必须对协议中的方法进行实现
}
```  

### 11.4.2 协议的特点与应用

- 协议不是一种数据类型，没有构造方法也不需要实例化。
- 协议中可以定义一些属性和方法，但这些属性和方法只是声明，协议中并不实现这些属性和方法。遵守协议的数据类型来为其提供真正的实现。
- 在 Swift 语言中，协议使用 `protocol` 关键字来创建。

```
// 定义协议
protocol MyProtocol {
	// 定义实例属性
	var 属性1:类型(get) // 可读属性，不一定只读
	var 属性2:类型(set get) // 可读可写的属性
	static var 属性3:类型 // 静态属性
	// 定义实例方法
	func 方法1(参数列表)
	// 静态方法
	static func 方法2(参数列表)
}
// 遵守协议的类，进行实现
class MyClass: MyProtocol {
	// 必须实现协议中的属性和方法
}
```

- 可以将协议作为函数中参数的类型，其意义为此参数可以是任意遵守了此协议的数据类型

```
// 协议作为函数的参数类型
func test(param: MyProtocol) {
}
```

- 协议也可以作为某一个集合的元素类型，其意义为集合中的所有元素都必须遵守此协议

```
// 协议作为集合的元素类型
var arr:Array<MyProtocol>
```

- 协议可以继承，一个协议继承了另一个协议，它就拥有了父协议中声明的属性和方法

```
// 协议的继承
protocol SubProtocol: MyProtocol {
	// 此协议中自动继承了 MyProtocol 协议中约定的属性和方法
}
```

- 协议可以被类、结构体等数据类型遵守；如果希望某个协议只能被类遵守，则在声明协议时使用 `class` 关键字来修饰

```
protocol MyClassProtocol:class {
	// 此协议只能被类遵守
}
```

- 如果需要协议中约定的属性和方法是可选实现的，则可以将其声明为 `optional` 类型的，同时，需要将整个协议用 `@objc` 关键字修饰

```
@objc protocol MyProtocol {
	// 可选实现的方法
	optional func myFunction()
}
```

### 11.4.3 协议与扩展的结合

- 通过扩展可以为协议中约定的属性和方法提供一套默认的实现。这样所有遵守此协议的数据类型也都可以获取到扩展中的默认实现。

```
@objc protocol MyProtocol {
	// 可选实现的方法
	optional func myFunction()
}
// 为 MyProtocol 中的方法提供默认实现
extension MyProtocol {
	func myFunction(){
		// 默认的方法实现
	}
}
// 遵守 MyProtocol 协议的类也可以不用实现 myFunction 方法
class MyClass: MyProtocol {}
// MyClass 的实例可以直接调用协议中默认的实现方法
var mine = MyClass()
mine.myFunction()
```















