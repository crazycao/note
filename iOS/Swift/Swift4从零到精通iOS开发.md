# Swift4从零到精通iOS开发

# 第1章 学习环境的搭建
# 第2章 量值与基本数据类型
## 2.1 变量与常量
## 2.2 关于注释
## 2.3 基本数据类型
## 2.4 两种特殊的基本数据类型
## 2.5 为类型取别名
# 第3章 字符、字符串与集合类型
## 3.1 字符串类型
## 3.2 字符类型
## 3.3 字符串类型中的常用方法
## 3.4 集合类型
### 3.4.1 Array数组类型
### 3.4.2 Set集合类型

- 不关注其中元素的顺序，但是其中的元素不可以重复。
- Set集合可以进行数学运算，如交集、并集、补集等。

### 3.4.3 Dictionary字典类型
# 第4章 基本运算符与程序流程控制
## 4.1 初识运算符
### 4.1.1 赋值运算符（=）
### 4.1.2 基本算数运算符（+、-、*、/、%）

- Swift 2.2 之后删除了自增运算符（++）和自减运算符（--）。

### 4.1.3 基本逻辑运算符（&&、||、!）
### 4.1.4 比较运算符（==、<、>、!=、<=、>=）
### 4.1.5 条件运算符（?:）
## 4.2 两种特殊的运算符
### 4.2.1 空合并运算符（??）

- `q ?? 0` 等价于 `(q!=nil)?(q!):0`，非空则拆包，否则取第二个值。

### 4.2.2 区间运算符（...、..<、>..、~=）

- `0...10` 表示 >=0 且 <=10 的闭区间
- `0..<10` 表示 >=0 且 <10 的半开区间
- `range1~=8` 表示 8 是否包含于区间 range1 中

## 4.3 循环结构
### 4.3.1 for-in循环结构

- Swift 2.2 之后删除了经典的for()循环结构。for-in结构已经完全覆盖其功能。

### 4.3.2 while与repeat-while条件循环结构

- repeat-while 就是 do-while

## 4.4 条件选择与多分支选择结构
### 4.4.1 if与if-else条件选择结构
### 4.4.2 switch-case多分支选择结构
- 支持任意数据类型的匹配
- 一个case子句匹配成功执行后，不用写break，会自动跳出switch结构，这与C语言等有很大不同

## 4.5 流程跳转语句
- continue：跳过本次循环，直接进入下一个循环周期
- break：终端循环
- fallthrough：需要switch-case结构不自动跳出，而执行下一个条件判断。写在之前break的位置。
- return：返回结果值
- throw：异常抛出。throw语句抛出的异常如果不进行捕获处理，也会使程序中断。
- guard：确保某个条件成立后才允许其后面的代码执行。

# 第5章 函数与闭包技术
## 5.1 函数的基本应用
- 完整的函数声明：

	```
	func 函数名(外部参数名1 内部参数名1:参数类型, 外部参数名2 内部参数名2:参数类型, ...)->返回值类型 {
	 // 实现部分 
	}
	```
- 函数的调用：

	```
	返回值 = 函数名(外部参数名1:参数值1, 外部参数名2:参数值2, ...)
	```

### 5.1.1 函数的创建与调用
### 5.1.2 关于函数的参数名
- 参数的外部名称会在调用函数时标识参数，既简化了函数名（OC），也能识别每个参数的意义（Java）。
- 可以省略函数参数的外部名称，默认函数的外部名称与内部名称相同。

### 5.1.3 函数中参数的默认值、不定数量参数与inout参数
- 默认值：在函数声明中，`内部参数名:参数类型`后面加上`= 默认值`。
- 不定数量参数：在函数声明中，`内部参数名:参数类型`后面加上`...`。
- inout类型参数：可以在函数内部修改传递参数的变量的值，`内部函数名:inout 参数类型`；调用函数传参时需要使用`&`符号取地址。

## 5.2 函数的类型与函数嵌套
- 函数变量的类型由参数和返回值决定，参数和返回值相同的函数类型就相同。
- 一个函数的类型形如：`(参数类型1, 参数类型2, ...)->返回值类型`。
- 声明一个函数变量：`var addFunc:(Int, Int)->Int`。

## 5.3 理解闭包结构
### 5.3.1 闭包的语法结构
- 标准闭包结构：`{(参数列表)->返回值 in 闭包体}`
- 闭包的返回值可以省略，会根据闭包体 `return` 返回的数据类型推测。

### 5.3.2 通过实现一个排序函数来深入理解闭包
## 5.4 将闭包作为参数传递时的写法优化
## 5.5 后置闭包、逃逸闭包与自动闭包
### 5.5.1 后置闭包
- 当函数中的最后一个参数为闭包函数时，在调用函数时，开发者可以将闭包结构脱离出函数的参数列表，追加在函数的尾部，增强代码的可读性。
- `函数名(参数1: 参数值, 参数2: 闭包体)`使用后置闭包的写法为：`函数名(参数1: 参数值)函数体`。

### 5.5.2 逃逸闭包
- 逃逸闭包，是指函数内的闭包在函数执行结束后在函数外依然可以进行使用；非逃逸闭包是指当函数的生命周期结束后，闭包也将被销毁。
- 参数中的闭包默认都是非逃逸的。逃逸类型的闭包常用于异步操作中。
- 逃逸闭包需要使用 @escaping 来声明。`func 函数名(参数名: @escaping 闭包声明)`。

### 5.5.3 自动闭包
- 在函数参数中，自动生成的简单闭包，通常称为自动闭包。
- 自动闭包不能够有参数，并且在调用函数传参时，此闭包的实现智能由一句表达式组成，闭包的返回值即为此表达式的值。
- 自动闭包参数由 `@autoclosure` 来声明.

# 第6章 高级运算符与枚举
## 6.1 位运算与溢出运算符
### 6.1.1 位运算符的应用
- `~`：按位取反运算符
- `&`：按位与运算符
- `|`：按位或运算符
- `^`：按位异或运算符
- `<<`：按位左移运算符
- `>>`：按位右移运算符

### 6.1.2 溢出运算符
溢出运算支持超出当前数据类型，取值仍截取当前数据类型。比如，
```
var b:UInt8 = 255
b = b &+ 1 // b 值变为 0

- `&+`：支持溢出的加操作
- `&-`：支持溢出的减操作
- `&*`：支持溢出的乘操作

## 6.2 运算符的重载与自定义
### 6.2.1 重载运算符
- 运算符的重载是指在系统已经存在的运算符上扩展新的功能。
- 重载运算符的语法格式与函数十分相似。

### 6.2.2 自定义运算符
- 开发者也可以通过自定义系统不存在的运算符来实现特殊的需求。
- 自定义运算符分为两个步骤，首先开发者需要将要定义的运算符进行声明，然后通过实现该运算符的函数。

## 6.3 运算符的优先级与结合性
## 6.4 枚举类型的创建与应用

- 创建枚举

```
enum 枚举类型名称 {
	case 枚举值1
	case 枚举值2
	...
}
```

- 使用枚举

```
// 完成写法
var 枚举变量:枚举类型名称 = 枚举类型名称.枚举值
// 如果一个变量的类型已经确认，那么赋值时可以省略枚举名称
var 枚举变量:枚举类型名称 = .枚举值
```

## 6.5 枚举的原始值与相关值
### 6.5.1 枚举的原始值

- 枚举的原始值特性可以将枚举值与另一种数据类型进行绑定

```
enum 枚举类型名称 {
	case 枚举值1 = 原始值1
	case 枚举值2 = 原始值2
	...
}
```

- 如果枚举的原始值类型为 `Int`，可以只设置第一个枚举值的原始值，其后的枚举值的原始值会依次递增。
- 通过枚举类型的中的 `rawValue` 属性来获取原始值

```
var 变量 = 枚举类型名称.枚举值.rawValue // 此后变量的值就是枚举的原始值
```

- 可以通过原始值来构造枚举变量（如果这个枚举有指定的原始值）

```
var 枚举变量 = 枚举类型名称(rawValue: 原始值)
```

### 6.5.2 枚举的相关值

- 枚举的相关值可以为枚举值关联一些其他数据
- 创建带相关值的枚举类型

```
enum 枚举类型名称 {
	case 枚举值1(参数1:参数类型1, 参数2:参数类型2, ...)
	case 枚举值2(参数列表 ...)
	...
} // 每个枚举值的参数列表就被称为为枚举的相关值
```

- 在创建有相关值的枚举实例时，开发者需要提供参数列表中所需要的参数

```
var 枚举变量 = 枚举类型名称.枚举值(参数1:参数值1, 参数2:参数值2, ...)
```

- 在 `switch-case` 结构语句中，可以通过参数捕获的方式来获取枚举变量的相关值，并且相关值参数可以在开发者的代码中使用

```
switch 枚举变量 {
	case let .枚举值1(参数1, 参数2, ...): {
		print("params1:\(参数1), params2:\(参数2)")
	}
	case let .枚举值2(参数列表...): {
	}
	...
}
```

### 6.5.3 递归枚举

- 枚举的递归是指，一个枚举值的相关值类型可以设置为这个枚举本身的类型
- 使用 indirect 关键字修饰的枚举值表示这个枚举值是可以递归的（即此枚举值中的相关值可以使用其枚举类型本身）

```
enum 枚举类型名称 {
	// 普通枚举值
	case 枚举值1
	// 带相关值的枚举值
	case 枚举值2(参数列表...)
	// 可递归的枚举值
	indirect case 枚举值3(参数1:参数类型1, ...) // 参数类型可以是当前枚举类型
}
```

- 如果一个枚举中所有的枚举值都是可递归的，可以直接将整个枚举类型声明为可递归的

```
// 可递归的枚举类型
indirect enum 枚举类型名称 {
	case 枚举值1(参数列表...) // 参数类型可以是当前枚举类型
	...
}
```

# 第7章 类与结构体

## 7.1 类与结构体的定义
### 7.1.1 结构体
- 结构体是用于描述一种事物的结构。
- 使用 `struct` 关键字来定义结构体
- 结构体中可以声明变量或者常量作为结构体的属性，有可以创建函数作为结构体的方法

```
struct 结构体名称 {
	// 属性（变量或常量）
	var 属性1: 类型1
	let 属性2: 类型2
	// 方法
	func 方法名(参数列表) {
		// 方法操作...
	}
}
```

- 结构体、枚举都是值类型，值类型的数据在进行值传递时总是被复制，修改新的实例并不影响原始的实例。
- 结构体实例的初始化

```
var 结构体变量 = 结构体名称(属性1:值1, 属性2:值2)
```

### 7.1.2 类

- 类是编程世界中万物的抽象，使用类可以模拟万物的对象。
- 使用 `class` 关键字来定义类
- 类中声明属性和方法的代码基本都一样，但是类要求开发者自己提供构造方法

```
class 类名 {
	// 属性（变量或常量）
	var 属性1: 类型1
	let 属性2: 类型2
	// 方法
	func 方法名(参数列表) {
		// 方法操作...
	}
	// 构造方法（如果类的每个属性声明时都设置了初始值，就可以不用构造方法）
	init(属性1:类型1, 属性2:类型2) {
		self.属性1 = 参数1
		self.属性2 = 参数2
	}
}
```

- 类是引用类型，通过引用计数来管理其生命周期。对类实例进行数据传递时只传递指针，并不会产生复制行为，修改新的变量会影响到原始变量。

### 7.1.3 类与结构体的异同

- 相同点
	- 都有属性、方法，并且声明代码完全相同
	- 都通过点语法来完成对属性和方法的访问
- 不同点
	- 结构体不具备继承特性
	- 结构体是值类型，类是引用类型
	- 结构体会根据属性自动生成一个构造方法，而类需要开发者自己实现 `init()` 方法
	- 对结构体进行比较，使用 `==`；对类进行比较，使用 `===`。
		- 在 Swift 中， Array、String、Dictionary、Set 这些数据类型都是采用结构体实现的，这与OC有很大的区别。 


## 7.2 设计以及各交通工具类
- `final` 关键字用于修饰某些终极的属性、方法或类。
	- 被 `final` 修饰的属性和方法不能够被子类覆写。
	- 被 `final` 修饰的类不能被继承。

## 7.3 开发中类与结构体的应用场景
- 适合使用结构体的场景：
	- 要描述的数据类型中只有少量的简单数据类型的属性
	- 要描述的数据类型在数据传递时需要以复制的方式进行
	- 要描述的数据类型中的所有属性在进行传递时需要以复制的方式进行
	- 不需要继承另一个数据类型

# 第8章 属性与方法

## 8.1 存储属性与计算属性
- 存储顺序性的作用是存储类的某个特征，而计算属性的作用是通过运算告知外界类的某个特征。
- 存储属性只能用于类和结构体，计算属性可以用于类、结构体和枚举。

### 8.1.1 存储属性的意义及应用
- 存储属性用于定义类或结构体的某些特性。
	- 存储属性就是用变量或常量存储的某些有意义的值。
- 当类实例被构造完成时，必须保证类中所有的属性都构造或者初始化完成。
	- 由开发者在创建的类中提供一个构造方法
	- 也可以为类中的属性在声明时就提供一个初始值
- 所谓延时存储属性就是指在类实例构造的时候，延时属性并不进行构造或初始化，只有当开发者调用到类实例的这个属性时，此属性才完成构造或者初始化操作。
	- 在 `var` 之前加上 `lazy` 修饰，标识这个属性是延时存储属性

```
lazy var 属性名称:类型
```

### 8.1.2 计算属性的意义及应用
- 计算属性用于描述可以由其他属性通过计算而得到的属性。
- 计算属性可以定义 `get` 与 `set` 方法，实际上是作为一个接口向外界提供某些经过计算后具有相应意义的数据。

```
var 属性名称:类型{
	get {
		// 计算过程...
		return 计算结果
	}
	set {
		// 对其他存储属性计算和赋值
		// 外界所设置的值默认以 newValue 的名字传入
	}
}
``` 

- 可以存在没有 `set` 方法块的计算属性，这种属性可以简写如下

```
var 属性名称:类型 {
	// 计算过程...
	return 计算结果
}
```

- 计算属性的值会受到外界影响而变化，一定是一个变量，所以必须用 `var` 修饰

## 8.2 属性监听器
- 属性监听器用于监听存储属性赋值的过程（计算属性不可以）
- 开发者可以在属性监听器中编写代码，添加额外的逻辑
- 在进行属性的构造或初始化时，都不会调用属性监听器的方法；初始化以后的第2次属性赋值开始，属性监听器才生效。

```
var 属性名称:类型 {
	willSet {
		// 属性将要被赋值时会调用的方法
		// 其中会默认生成一个 newValue 来接收外界传进来的新值
	}
	didSet {
		// 属性已经被赋值后会调用的方法
		// 其中会默认生成一个 oldValue 来保存此属性的原始值
	}
}
```

## 8.3 实例属性与类属性
- 实例属性是与具体实例现相关联的，一般用来描述类实例的一些特性；类属性是与此类型相关联的，用来描述整个类型的某些特性。
- 类属性使用 `static` 或 `class` 关键字来声明，使用 `static` 关键字声明的属性也被称为静态属性。

```
class 类名 {
	static var 属性名称: 类型
	class var 属性名称: 类型
}
```

- 使用类属性时，不需要创建实例对象，直接使用类名来调用

```
类名.属性名
```

- 对于类计算属性，如果允许子类对其计算方法进行覆写，则需要用 `class` 关键字来声明，并且覆写时需要使用 `override` 关键字

```
class 类名 {
	class var 属性名称: 类型 {
		return 计算值
	}
}

class 子类名:父类名 {
	override class var 继承的属性名称: 类型 {
		return 覆写计算值
	}
}

```

## 8.4 实例方法与类方法

### 8.4.1 实例方法的意义与应用
- 方法只是一个术语，其实质就是将函数与特定的类型进行结合。
	- 实例方法在语法上与函数完全一致。
- 类的每个实例中都默认隐藏这一个名为 `self` 的属性，`self` 就是实例本身，开发者可以在实例方法中通过 `self` 来调用类的属性和其他实例方法。
	- 一般情况下，`self` 也可以被省略
- 如果需要在实例方法中对类中值类型的属性进行修改，需要用 `mutating` 关键字修饰实例方法

```
mutating func 方法名(参数列表) {
	...
	self.属性名 = xxxx
	...
}
```

### 8.4.2 类方法

- 类方法是关联与整个类型的，被整个类型所共享。
- 类方法的用法与类属性相同，也是通过 `static` 和 `class` 关键字来声明的。
- `static` 关键字声明的类方法又被称为静态方法，不能被子类覆写；`class` 声明的类方法可以被子类覆写。
- 在类方法中也可以使用 `self` 关键字，但此时 `self` 代表的是当前类，而非实例。

## 8.5 下标方法
- 对于Set、Array等数据结构，可以通过使用下标来获取其中的元素，如 array[2]。
- 下标实际上是一个 `subscript` 方法，参数和返回值分别为下标和通过下标所取的值
	- `subscript` 是 Swift 语言中用于定义下标功能的方法
- `subscript` 方法的实现与计算属性十分类似，有一个必须实现的 `get` 代码块和一个可选的 `set` 代码块

# 第9章 构造方法与析构方法



























