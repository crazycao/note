# Swift4从零到精通iOS开发

# 第1章 学习环境的搭建
# 第2章 量值与基本数据类型
## 2.1 变量与常量
## 2.2 关于注释
## 2.3 基本数据类型
## 2.4 两种特殊的基本数据类型
## 2.5 为类型取别名
# 第3章 字符、字符串与集合类型
## 3.1 字符串类型
## 3.2 字符类型
## 3.3 字符串类型中的常用方法
## 3.4 集合类型
### 3.4.1 Array数组类型
### 3.4.2 Set集合类型

- 不关注其中元素的顺序，但是其中的元素不可以重复。
- Set集合可以进行数学运算，如交集、并集、补集等。

### 3.4.3 Dictionary字典类型
# 第4章 基本运算符与程序流程控制
## 4.1 初识运算符
### 4.1.1 赋值运算符（=）
### 4.1.2 基本算数运算符（+、-、*、/、%）

- Swift 2.2 之后删除了自增运算符（++）和自减运算符（--）。

### 4.1.3 基本逻辑运算符（&&、||、!）
### 4.1.4 比较运算符（==、<、>、!=、<=、>=）
### 4.1.5 条件运算符（?:）
## 4.2 两种特殊的运算符
### 4.2.1 空合并运算符（??）

- `q ?? 0` 等价于 `(q!=nil)?(q!):0`，非空则拆包，否则取第二个值。

### 4.2.2 区间运算符（...、..<、>..、~=）

- `0...10` 表示 >=0 且 <=10 的闭区间
- `0..<10` 表示 >=0 且 <10 的半开区间
- `range1~=8` 表示 8 是否包含于区间 range1 中

## 4.3 循环结构
### 4.3.1 for-in循环结构

- Swift 2.2 之后删除了经典的for()循环结构。for-in结构已经完全覆盖其功能。

### 4.3.2 while与repeat-while条件循环结构

- repeat-while 就是 do-while

## 4.4 条件选择与多分支选择结构
### 4.4.1 if与if-else条件选择结构
### 4.4.2 switch-case多分支选择结构
- 支持任意数据类型的匹配
- 一个case子句匹配成功执行后，不用写break，会自动跳出switch结构，这与C语言等有很大不同

## 4.5 流程跳转语句
- continue：跳过本次循环，直接进入下一个循环周期
- break：终端循环
- fallthrough：需要switch-case结构不自动跳出，而执行下一个条件判断。写在之前break的位置。
- return：返回结果值
- throw：异常抛出。throw语句抛出的异常如果不进行捕获处理，也会使程序中断。
- guard：确保某个条件成立后才允许其后面的代码执行。

# 第5章 函数与闭包技术
## 5.1 函数的基本应用
- 完整的函数声明：

	```
	func 函数名(外部参数名1 内部参数名1:参数类型, 外部参数名2 内部参数名2:参数类型, ...)->返回值类型 {
	 // 实现部分 
	}
	```
- 函数的调用：

	```
	返回值 = 函数名(外部参数名1:参数值1, 外部参数名2:参数值2, ...)
	```

### 5.1.1 函数的创建与调用
### 5.1.2 关于函数的参数名
- 参数的外部名称会在调用函数时标识参数，既简化了函数名（OC），也能识别每个参数的意义（Java）。
- 可以省略函数参数的外部名称，默认函数的外部名称与内部名称相同。

### 5.1.3 函数中参数的默认值、不定数量参数与inout参数
- 默认值：在函数声明中，`内部参数名:参数类型`后面加上`= 默认值`。
- 不定数量参数：在函数声明中，`内部参数名:参数类型`后面加上`...`。
- inout类型参数：可以在函数内部修改传递参数的变量的值，`内部函数名:inout 参数类型`；调用函数传参时需要使用`&`符号取地址。

## 5.2 函数的类型与函数嵌套
- 函数变量的类型由参数和返回值决定，参数和返回值相同的函数类型就相同。
- 一个函数的类型形如：`(参数类型1, 参数类型2, ...)->返回值类型`。
- 声明一个函数变量：`var addFunc:(Int, Int)->Int`。

## 5.3 理解闭包结构
### 5.3.1 闭包的语法结构
- 标准闭包结构：`{(参数列表)->返回值 in 闭包体}`
- 闭包的返回值可以省略，会根据闭包体 `return` 返回的数据类型推测。

### 5.3.2 通过实现一个排序函数来深入理解闭包
## 5.4 将闭包作为参数传递时的写法优化
## 5.5 后置闭包、逃逸闭包与自动闭包
### 5.5.1 后置闭包
- 当函数中的最后一个参数为闭包函数时，在调用函数时，开发者可以将闭包结构脱离出函数的参数列表，追加在函数的尾部，增强代码的可读性。
- `函数名(参数1: 参数值, 参数2: 闭包体)`使用后置闭包的写法为：`函数名(参数1: 参数值)函数体`。

### 5.5.2 逃逸闭包
- 逃逸闭包，是指函数内的闭包在函数执行结束后在函数外依然可以进行使用；非逃逸闭包是指当函数的生命周期结束后，闭包也将被销毁。
- 参数中的闭包默认都是非逃逸的。逃逸类型的闭包常用于异步操作中。
- 逃逸闭包需要使用 @escaping 来声明。`func 函数名(参数名: @escaping 闭包声明)`。

### 5.5.3 自动闭包
- 在函数参数中，自动生成的简单闭包，通常称为自动闭包。
- 自动闭包不能够有参数，并且在调用函数传参时，此闭包的实现智能由一句表达式组成，闭包的返回值即为此表达式的值。
- 自动闭包参数由 `@autoclosure` 来声明.

# 第6章 高级运算符与枚举
## 6.1 位运算与溢出运算符
### 6.1.1 位运算符的应用
- `~`：按位取反运算符
- `&`：按位与运算符
- `|`：按位或运算符
- `^`：按位异或运算符
- `<<`：按位左移运算符
- `>>`：按位右移运算符

### 6.1.2 溢出运算符
溢出运算支持超出当前数据类型，取值仍截取当前数据类型。比如，
```
var b:UInt8 = 255
b = b &+ 1 // b 值变为 0

- `&+`：支持溢出的加操作
- `&-`：支持溢出的减操作
- `&*`：支持溢出的乘操作

## 6.2 运算符的重载与自定义
### 6.2.1 重载运算符
- 运算符的重载是指在系统已经存在的运算符上扩展新的功能。
- 重载运算符的语法格式与函数十分相似。

### 6.2.2 自定义运算符
- 开发者也可以通过自定义系统不存在的运算符来实现特殊的需求。
- 自定义运算符分为两个步骤，首先开发者需要将要定义的运算符进行声明，然后通过实现该运算符的函数。

